use crate::resp::{BulkString, CommandArgs};
use dtoa::Float;
use itoa::Integer;
use smallvec::SmallVec;
use std::{
    collections::{BTreeMap, BTreeSet, HashMap, HashSet},
    hash::BuildHasher,
};

/// Types compatible with command args
pub trait Args {
    /// Write this Rust type as one ore multiple args into CommandArgs.
    ///
    /// Primitives Rust types will generate a single argument
    /// whereas collections and tuples will generate multiple arguments
    fn write_args(&self, args: &mut CommandArgs);

    /// Number arguments generated by this Rust type
    #[inline]
    fn num_args(&self) -> usize {
        1
    }
}

#[inline]
fn write_integer<I: Integer>(i: I, args: &mut CommandArgs) {
    let mut buf = itoa::Buffer::new();
    let str = buf.format(i);
    args.write_arg(str.as_bytes().to_vec());
}

#[inline]
fn write_float<F: Float>(f: F, args: &mut CommandArgs) {
    let mut buf = dtoa::Buffer::new();
    let str = buf.format(f);
    args.write_arg(str.as_bytes().to_vec());
}

impl Args for i8 {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        write_integer(*self, args);
    }
}

impl Args for i16 {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        write_integer(*self, args);
    }
}

impl Args for u16 {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        write_integer(*self, args);
    }
}

impl Args for i32 {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        write_integer(*self, args);
    }
}

impl Args for u32 {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        write_integer(*self, args);
    }
}

impl Args for i64 {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        write_integer(*self, args);
    }
}

impl Args for u64 {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        write_integer(*self, args);
    }
}

impl Args for isize {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        write_integer(*self, args);
    }
}

impl Args for usize {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        write_integer(*self, args);
    }
}

impl Args for f32 {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        write_float(*self, args);
    }
}

impl Args for f64 {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        write_float(*self, args);
    }
}

impl Args for bool {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        args.write_arg(if *self { vec![b'1'] } else { vec![b'0'] });
    }
}

impl Args for BulkString {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        args.write_arg(self.as_bytes().to_vec());
    }
}

impl Args for Vec<u8> {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        args.write_arg(self.clone());
    }
}

impl Args for &[u8] {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        args.write_arg(self.to_vec());
    }
}

impl<const N: usize> Args for &[u8; N] {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        args.write_arg(self.as_slice().to_vec());
    }
}

impl<const N: usize> Args for [u8; N] {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        args.write_arg(self.as_slice().to_vec());
    }
}

impl Args for &str {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        args.write_arg(self.as_bytes().to_vec());
    }
}

impl Args for String {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        args.write_arg(self.as_bytes().to_vec());
    }
}

impl Args for &String {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        args.write_arg(self.as_bytes().to_vec());
    }
}

impl Args for char {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        let mut buf: [u8; 4] = [0; 4];
        self.encode_utf8(&mut buf);
        args.write_arg(buf.as_slice().to_vec());
    }
}

impl<T: Args> Args for Option<T> {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        if let Some(t) = self {
            t.write_args(args);
        }
    }

    #[inline]
    fn num_args(&self) -> usize {
        match self {
            Some(t) => t.num_args(),
            None => 0,
        }
    }
}

impl<T: Args, const N: usize> Args for [T; N] {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        for e in self {
            e.write_args(args);
        }
    }

    #[inline]
    fn num_args(&self) -> usize {
        self.iter().fold(0, |acc, t| acc + t.num_args())
    }
}

impl<T: Args> Args for Vec<T> {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        for e in self {
            e.write_args(args);
        }
    }

    #[inline]
    fn num_args(&self) -> usize {
        self.iter().fold(0, |acc, t| acc + t.num_args())
    }
}

impl<T: Args> Args for &[T] {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        for e in self.iter() {
            e.write_args(args);
        }
    }

    #[inline]
    fn num_args(&self) -> usize {
        self.iter().fold(0, |acc, t| acc + t.num_args())
    }
}

impl<T, A> Args for SmallVec<A>
where
    A: smallvec::Array<Item = T>,
    T: Args,
{
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        for e in self {
            e.write_args(args);
        }
    }

    #[inline]
    fn num_args(&self) -> usize {
        self.iter().fold(0, |acc, t| acc + t.num_args())
    }
}

impl<T, S: BuildHasher> Args for HashSet<T, S>
where
    T: Args,
{
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        for e in self {
            e.write_args(args);
        }
    }

    #[inline]
    fn num_args(&self) -> usize {
        self.iter().fold(0, |acc, t| acc + t.num_args())
    }
}

impl<T> Args for BTreeSet<T>
where
    T: Args,
{
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        for e in self {
            e.write_args(args);
        }
    }

    #[inline]
    fn num_args(&self) -> usize {
        self.iter().fold(0, |acc, t| acc + t.num_args())
    }
}

impl<K, V, S: BuildHasher> Args for HashMap<K, V, S>
where
    K: Args,
    V: Args,
{
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        for (key, value) in self {
            key.write_args(args);
            value.write_args(args);
        }
    }

    #[inline]
    fn num_args(&self) -> usize {
        self.iter()
            .fold(0, |acc, (k, v)| acc + k.num_args() + v.num_args())
    }
}

impl<K, V> Args for BTreeMap<K, V>
where
    K: Args,
    V: Args,
{
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        for (key, value) in self {
            key.write_args(args);
            value.write_args(args);
        }
    }

    #[inline]
    fn num_args(&self) -> usize {
        self.iter()
            .fold(0, |acc, (k, v)| acc + k.num_args() + v.num_args())
    }
}

impl<T, U> Args for (T, U)
where
    T: Args,
    U: Args,
{
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        self.0.write_args(args);
        self.1.write_args(args);
    }

    #[inline]
    fn num_args(&self) -> usize {
        self.0.num_args() + self.1.num_args()
    }
}

impl<T, U, V> Args for (T, U, V)
where
    T: Args,
    U: Args,
    V: Args,
{
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        self.0.write_args(args);
        self.1.write_args(args);
        self.2.write_args(args);
    }

    #[inline]
    fn num_args(&self) -> usize {
        self.0.num_args() + self.1.num_args() + self.2.num_args()
    }
}

impl Args for CommandArgs {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        for arg in self {
            args.write_arg(arg.to_vec());
        }
    }

    #[inline]
    fn num_args(&self) -> usize {
        self.len()
    }
}

impl Args for &CommandArgs {
    #[inline]
    fn write_args(&self, args: &mut CommandArgs) {
        for arg in self.into_iter() {
            args.write_arg(arg.to_vec());
        }
    }

    #[inline]
    fn num_args(&self) -> usize {
        self.len()
    }
}

/// A wrapper type that adapts any clonable iterator of `Args` items to `Args` traits.
///
/// # Purpose
///
/// `ArgIterator` allows you to use any iterator of items implementing `Args` (such as produced by `.iter()` or more complex iterator adapters)
/// as a collection of arguments for Redis commands, without needing to collect your data into a concrete Vec or slice first.
/// This is particularly useful for building command arguments on-the-fly, avoiding unnecessary allocations.
///
/// # Requirements
///
/// - The underlying iterator must implement [`Clone`] so that it can be traversed twice:
///   - once for counting arguments (`num_args`)
///   - once for serializing them (`write_args`)
/// - The iterator's items must implement [`Args`].
///
/// # Note
/// Most common iterators in Rust are clonable, including those produced by `.iter()`, `.cloned()`, `.map()`, and ranges.
/// If you use a non-clonable iterator, this wrapper will not compile.
pub struct ArgIterator<I>
where
    I: Iterator + Clone,
    I::Item: Args,
{
    iter: I,
}

impl<I> ArgIterator<I>
where
    I: Iterator + Clone,
    I::Item: Args,
{
    /// Constructs a new `ArgIterator` from any clonable iterator of `Args` items.    
    pub fn new(iter: I) -> Self {
        ArgIterator { iter }
    }
}

/// Adapts any clonable iterator of `Args` items to the `Args` traits.
impl<I> Args for ArgIterator<I>
where
    I: Iterator + Clone,
    I::Item: Args,
{
    fn write_args(&self, args: &mut CommandArgs) {
        for item in self.iter.clone() {
            item.write_args(args);
        }
    }
    fn num_args(&self) -> usize {
        self.iter.clone().fold(0, |acc, t| acc + t.num_args())
    }
}

/// Convenience function for constructing a [`ArgIterator`] from any clonable iterator of `Args` items.
pub fn arg_iter<T, I>(iter: I) -> ArgIterator<I>
where
    I: Iterator<Item = T> + Clone,
    T: Args,
{
    ArgIterator::new(iter)
}

/// A wrapper type that adapts any clonable iterator of references to `Args` items
/// to `Args` traits.
///
/// # Purpose
///
/// `RefIterator` allows you to use any clonable iterator over references to items implementing `Args`
/// (such as produced by `.iter()` on a `Vec<T>` or slice) as a collection of arguments for Redis commands,
/// without needing to collect your data into a concrete Vec or slice first. This is especially useful for
/// passing arguments by reference, avoiding unnecessary cloning or allocation.
///
/// # Requirements
///
/// - The underlying iterator must be clonable ([`Clone`]), so it can be traversed twice:
///   - once for counting arguments (`num_args`)
///   - once for serializing them (`write_args`)
/// - The iterator's items must be references to a type implementing [`Args`].
///
/// # Note
/// Most iterators produced by `.iter()` on collections are clonable.
/// If you use a non-clonable iterator, this wrapper will not compile.
///
/// # Lifetime
/// The lifetime parameter `'a` ensures that the iterator and the referenced items outlive
/// the usage of this wrapper.
pub struct ArgRefIterator<'a, I, T>
where
    I: Iterator<Item = &'a T> + Clone,
    T: Args + 'a,
{
    iter: I,
}

impl<'a, I, T> ArgRefIterator<'a, I, T>
where
    I: Iterator<Item = &'a T> + Clone,
    T: Args + 'a,
{
    /// Constructs a new `ArgRefIterator` from any clonable iterator of references to `Args` items.
    pub fn new(iter: I) -> Self {
        ArgRefIterator { iter }
    }
}

/// Implements argument serialization and counting for an iterator of references to `Args` items.
impl<'a, I, T> Args for ArgRefIterator<'a, I, T>
where
    I: Iterator<Item = &'a T> + Clone,
    T: Args + 'a,
{
    fn write_args(&self, args: &mut CommandArgs) {
        for item in self.iter.clone() {
            item.write_args(args);
        }
    }
    fn num_args(&self) -> usize {
        self.iter.clone().fold(0, |acc, t| acc + t.num_args())
    }
}

/// Convenience function for constructing a [`ArgRefIterator`] from any clonable iterator of references to `Args` items.
///
/// # Example
///
/// ```rust
/// use rustis::{
///     client::Client, commands::{FlushingMode, ServerCommands, GenericCommands},
///     resp::{cmd, arg_ref_iter, Value}, Result,
/// };
///
/// #[cfg_attr(feature = "tokio-runtime", tokio::main)]
/// #[cfg_attr(feature = "async-std-runtime", async_std::main)]
/// async fn main() -> Result<()> {
///     let client = Client::connect("127.0.0.1:6379").await?;
///     client.flushdb(FlushingMode::Sync).await?;
///
///     let keys = vec!["key1", "key2", "key3"];
///     client.del(arg_ref_iter(keys.iter())).await?;
///
///     Ok(())
/// }
/// ```
pub fn arg_ref_iter<'a, I, T>(iter: I) -> ArgRefIterator<'a, I, T>
where
    I: Iterator<Item = &'a T> + Clone,
    T: Args + 'a,
{
    ArgRefIterator::new(iter)
}

/// A wrapper type that adapts any clonable iterator of `(K, V)` pairs (where both `K` and `V` implement `Args`)
/// to `Args` traits.
///
/// # Purpose
///
/// `KeyValueArgsIterator` allows you to use any clonable iterator of key-value pairs as a collection of arguments
/// for Redis commands that expect pairs (such as `MSET`, `HSET`, etc.), without needing to collect your data
/// into a concrete Vec or slice first. This enables building argument lists on-the-fly and avoids unnecessary allocations.
///
/// # Requirements
///
/// - The underlying iterator must implement [`Clone`] so it can be traversed twice:
///   - once for counting arguments (`num_args`)
///   - once for serializing them (`write_args`)
/// - Both key and value types must implement [`Args`].
///
/// # Note
/// Most iterators in Rust are clonable, including those produced by `.iter()`, `.cloned()`, `.map()`, and `.zip()`.
/// If you use a non-clonable iterator, this wrapper will not compile.
pub struct KeyValueArgsIterator<I, K, V>
where
    I: Iterator<Item = (K, V)> + Clone,
    K: Args,
    V: Args,
{
    iter: I,
}

impl<I, K, V> KeyValueArgsIterator<I, K, V>
where
    I: Iterator<Item = (K, V)> + Clone,
    K: Args,
    V: Args,
{
    /// Constructs a new `KeyValueArgsIterator` from any clonable iterator of `(K, V)` pairs.
    pub fn new(iter: I) -> Self {
        KeyValueArgsIterator { iter }
    }
}

/// Implements argument serialization and counting for an iterator of `(K, V)` pairs.
impl<I, K, V> Args for KeyValueArgsIterator<I, K, V>
where
    I: Iterator<Item = (K, V)> + Clone,
    K: Args,
    V: Args,
{
    fn write_args(&self, args: &mut CommandArgs) {
        for (key, value) in self.iter.clone() {
            key.write_args(args);
            value.write_args(args);
        }
    }
    fn num_args(&self) -> usize {
        self.iter
            .clone()
            .fold(0, |acc, (k, v)| acc + k.num_args() + v.num_args())
    }
}

/// Convenience function for constructing a [`KeyValueArgsIterator`] from any clonable iterator of `(K, V)` pairs.
pub fn key_value_args_iter<I, K, V>(iter: I) -> KeyValueArgsIterator<I, K, V>
where
    I: Iterator<Item = (K, V)> + Clone,
    K: Args,
    V: Args,
{
    KeyValueArgsIterator::new(iter)
}

/// A wrapper type that adapts any clonable iterator of references to `(K, V)` pairs (where both `K` and `V` implement `Args`)
/// to the `Args` traits.
///
/// # Purpose
///
/// `KeyValueArgsRefIterator` allows you to use any clonable iterator over references to key-value pairs
/// (such as produced by `.iter()` on a slice or a `Vec<(K, V)>`) as a collection of arguments for Redis commands that expect pairs,
/// like `MSET`, `HSET`, etc. This avoids unnecessary cloning or allocation and enables efficient argument passing by reference.
///
/// # Requirements
///
/// - The underlying iterator must implement [`Clone`] so it can be traversed twice:
///   - once for counting arguments (`num_args`)
///   - once for serializing them (`write_args`)
/// - The iterator's items must be references to tuples where both key and value types implement [`Args`].
///
/// # Examples
///
/// ```rust
/// use rustis::{
///     client::Client, commands::{FlushingMode, ServerCommands, StringCommands},
///     resp::{cmd, key_value_args_ref_iter, Value}, Result,
/// };
///
/// #[cfg_attr(feature = "tokio-runtime", tokio::main)]
/// #[cfg_attr(feature = "async-std-runtime", async_std::main)]
/// async fn main() -> Result<()> {
///     let client = Client::connect("127.0.0.1:6379").await?;
///     client.flushdb(FlushingMode::Sync).await?;
///
///     let map = vec![("foo", 1), ("bar", 2)];
///     client.mset(key_value_args_ref_iter(map.iter())).await?;
///
///     Ok(())
/// }
/// ```
///
/// This also works with arrays and slices:
///
/// ```rust
/// use rustis::{
///     client::Client, commands::{FlushingMode, ServerCommands, StringCommands},
///     resp::{cmd, key_value_args_ref_iter, Value}, Result,
/// };
///
/// #[cfg_attr(feature = "tokio-runtime", tokio::main)]
/// #[cfg_attr(feature = "async-std-runtime", async_std::main)]
/// async fn main() -> Result<()> {
///     let client = Client::connect("127.0.0.1:6379").await?;
///     client.flushdb(FlushingMode::Sync).await?;
///
///     let arr = [("a", 42), ("b", 43)];
///     client.mset(key_value_args_ref_iter(arr.iter())).await?;
///
///     Ok(())
/// }
/// ```
///
/// # Note
/// Most iterators produced by `.iter()` on collections or slices are clonable.  
/// If you use a non-clonable iterator, this wrapper will not compile.
///
/// # Lifetime
/// The lifetime parameter `'a` ensures that the iterator and the referenced pairs outlive
/// the usage of this wrapper.
///
pub struct KeyValueArgsRefIterator<'a, I, K, V>
where
    I: Iterator<Item = &'a (K, V)> + Clone,
    K: Args + 'a,
    V: Args + 'a,
{
    iter: I,
}

impl<'a, I, K, V> KeyValueArgsRefIterator<'a, I, K, V>
where
    I: Iterator<Item = &'a (K, V)> + Clone,
    K: Args + 'a,
    V: Args + 'a,
{
    /// Constructs a new `KeyValueArgsRefIterator` from any clonable iterator of references to `(K, V)` pairs.    
    pub fn new(iter: I) -> Self {
        KeyValueArgsRefIterator { iter }
    }
}

/// Implements argument serialization and counting for an iterator of references to `(K, V)` pairs.
impl<'a, I, K, V> Args for KeyValueArgsRefIterator<'a, I, K, V>
where
    I: Iterator<Item = &'a (K, V)> + Clone,
    K: Args + 'a,
    V: Args + 'a,
{
    fn write_args(&self, args: &mut CommandArgs) {
        for (key, value) in self.iter.clone() {
            key.write_args(args);
            value.write_args(args);
        }
    }
    fn num_args(&self) -> usize {
        self.iter
            .clone()
            .fold(0, |acc, (k, v)| acc + k.num_args() + v.num_args())
    }
}

/// Convenience function for constructing a [`KeyValueArgsRefIterator`] from any clonable iterator of references to `(K, V)` pairs.
///
/// # Example
///
/// ```rust
/// use rustis::{
///     client::Client, commands::{FlushingMode, ServerCommands, StringCommands},
///     resp::{cmd, key_value_args_ref_iter, Value}, Result,
/// };
///
/// #[cfg_attr(feature = "tokio-runtime", tokio::main)]
/// #[cfg_attr(feature = "async-std-runtime", async_std::main)]
/// async fn main() -> Result<()> {
///     let client = Client::connect("127.0.0.1:6379").await?;
///     client.flushdb(FlushingMode::Sync).await?;
///
///     let map = vec![("foo", 1), ("bar", 2)];
///     client.mset(key_value_args_ref_iter(map.iter())).await?;
///
///     Ok(())
/// }
/// ```
pub fn key_value_args_ref_iter<'a, I, K, V>(iter: I) -> KeyValueArgsRefIterator<'a, I, K, V>
where
    I: Iterator<Item = &'a (K, V)> + Clone,
    K: Args + 'a,
    V: Args + 'a,
{
    KeyValueArgsRefIterator::new(iter)
}
